#!/usr/bin/env node

"use strict";

/* eslint-disable no-console */

const { spawn } = require("child_process");
const fs = require("fs");
const path = require("path");
const argparse = require("argparse");

const testData =
      path.dirname(require.resolve(
        "@xml-conformance-suite/test-data/package.json"));

const { ResourceLoader } = require("../src/lib/resource-loader");
const { TestParser } = require("../src/lib/test-parser");

function loadTests(resourceLoader) {
  const parser = new TestParser(path.join(testData, "xmlconf"), resourceLoader);
  parser.parse(fs.readFileSync(path.join(testData,
                                         "cleaned/xmlconf-flattened.xml")));
  const { top } = parser;
  if (top.name !== "TESTSUITE") {
    throw new Error("the top level element must be TESTSUITE");
  }

  return top;
}

const parser = new argparse.ArgumentParser({
  addHelp: true,
  description: "Search through the test suite.",
});

function checkUnrecognized(unknown) {
  if (unknown && unknown.length) {
    parser.error(`Unrecognized arguments: ${unknown.join(", ")}`);
  }
}

function grepCommand(subargs) {
  const uris = [];
  loadTests(new ResourceLoader()).walkChildElements((child) => {
    if (child.name === "TEST") {
      uris.push(child.resolvedURI);
    }
  });

  if (!subargs.__extra) {
    parser.error("grep-xml at least needs a pattern");
  }

  spawn("grep", [].concat(subargs.__extra, uris), { stdio: "inherit" });
}

function findBOMCommand(subargs) {
  checkUnrecognized(subargs.__extra);

  const { method } = subargs;
  const promises = [];
  switch (method) {
  case "get-has-bom":
    loadTests(new ResourceLoader()).walkChildElements((child) => {
      if (child.name === "TEST") {
        promises.push(child.getHasBOM().then(bom => ({ test: child, bom })));
      }
    });
    break;
  case "bytes":
    loadTests(new ResourceLoader()).walkChildElements((child) => {
      if (child.name === "TEST") {
        promises.push(new Promise((resolve, reject) => {
          fs.readFile(child.resolvedURI, (err, buf) => {
            if (err) {
              reject(err);

              return;
            }

            let zero;
            try {
              zero = buf.readUInt16LE(0);
            }
            catch (ex) {
              if (ex instanceof RangeError) {
                resolve(false);
                return;
              }

              reject(ex);
              return;
            }

            resolve({
              test: child,
              bom: zero === 0xFFFE || zero === 0xFEFF,
            });
          });
        }));
      }
    });
    break;
  default:
    throw new Error(`unknown method: ${method}`);
  }

  Promise.all(promises)
    .then((results) => {
      for (const { test, bom } of results) {
        if (bom) {
          console.log(test.id);
        }
      }
    });
}

const XSL_TEMPLATE = `\
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="1.0">

 <xsl:template match="node()|@*">
   <xsl:apply-templates select="node()|@*"/>
 </xsl:template>

  <xsl:template match="@@EXPR@@">
    <xsl:choose>
      <xsl:when test="self::*">
        <xsl:copy-of select="."/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="."/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:text>&#xA;</xsl:text>
  </xsl:template>
</xsl:stylesheet>
`;

function selectCommand(subargs) {
  checkUnrecognized(subargs.__extra);

  const child = spawn("xsltproc",
                      ["-",
                       path.join(__dirname, "../cleaned/xmlconf-flattened.xml")],
                      { stdio: ["pipe", "inherit", "inherit"] });
  child.stdin.write(XSL_TEMPLATE.replace("@@EXPR@@", subargs.expr));
  child.stdin.end();
}

function catCommand(subargs) {
  checkUnrecognized(subargs.__extra);
  const { aspect, id } = subargs;
  switch (aspect) {
  case "definition":
    selectCommand({ expr: `//TEST[@ID='${id}']` });
    break;
  case "file":
    loadTests(new ResourceLoader()).walkChildElements((child) => {
      if (child.id === id) {
        console.log(fs.readFileSync(child.resolvedURI).toString());
      }
    });
    break;
  default:
    throw new Error(`uknown aspect: ${aspect}`);
  }
}

const subparsers = parser.addSubparsers({
  title: "subcommands",
  dest: "subcommand",
});

const grepXML = subparsers.addParser("grep-xml", {
  description: "Run grep on the XML of the test files. All parameters you pass \
are passed on to grep.",
  help: "Run grep on the XML of the test files.",
});

grepXML.setDefaults({ func: grepCommand });

const select = subparsers.addParser("select", {
  description: "Select tests by XPath expression.",
  help: "Select tests by XPath expression.",
});

select.addArgument("expr", {
  help: "An XPath 1.0 expression.",
});

select.setDefaults({ func: selectCommand });

const findBOM = subparsers.addParser("find-bom", {
  description: "Select tests that have a BOM in their main file.",
  help: "Select tests that have a BOM in their main file.",
});

findBOM.setDefaults({ func: findBOMCommand });

findBOM.addArgument(["-m", "--method"], {
  action: "store",
  choices: ["get-has-bom", "bytes"],
  defaultValue: "get-has-bom",
  help: "Select a method for checking the presence of the BOM. ``get-has-bom`` \
uses the ``getHasBOM`` method of ``Test`` elements. ``bytes`` reads the XML in \
binary mode. Default: ``%(defaultValue)s``.",
});


const cat = subparsers.addParser("dump", {
  description: "Dump a test to the screen.",
  help: "Dump a test to the screen.",
});

cat.setDefaults({ func: catCommand });

cat.addArgument("id", {
  action: "store",
  help: "The id of the test.",
});

cat.addArgument(["-a", "--aspect"], {
  action: "store",
  choices: ["definition", "file"],
  defaultValue: "definition",
  help: "Select which aspect of the test to dump. ``definition`` selects the \
test definition. ``file`` selects the test file.",
});

// Patch argparse so that parseKnownArgs works with subparsers.
argparse.ArgumentParser.prototype.parseArgs = function parseArgs(...params) {
  const [namespace, extra] = this.parseKnownArgs(...params);
  if (extra.length) {
    // We stuff the unrecognized parameters into an __extra field. Otherwise,
    // they are lost.
    namespace.__extra = (namespace.__extra || []).concat(extra);
  }

  return namespace;
};

const [args] = parser.parseKnownArgs();

checkUnrecognized(args);

args.func(args);
